---
title: "US Sex Education/Teen Pregnancy-Birth Rates - Geospatial project"
author: "Melanie Fisher"
date: "2024-05-01"
output: html_document
---
#Does a teenager's location in the United States increase ones chances of getting pregnant?

#Do counties with high teenage birthrates neighbor other counties with high teenage birthrates?
#Do states level of sexual education impact Teenage Birth Rates?
Is there a difference between rural and urban counties?
regression - can predict teenage birth rates based on sexedu

Descriptive/Exploratory - without trying to model it
spatial autocorrelation between of birthrates, if there are clusters try to make a hypothesis about why, could map it out

is religious beliefs, general school policies - clustering - local Moran I
why there are these geospatial difference


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
#Relevant Definitions
Pregnancy rate: refers to the rate of successful pregnancies.
Birth Rate: number of live births per thousand of population per year
```{r}
library(terra) |> suppressMessages()
library(tmap)|> suppressMessages()
library(stringr) |> suppressMessages()
library(spdep) # package for spatial dependence
library(sf)|> suppressMessages()
library(dplyr)|> suppressMessages()
library(tidyverse)|> suppressMessages()
library(maps)|> suppressMessages()
library(readxl)|> suppressMessages()
library(tigris)
library(ggplot2)
library(ggpattern)
library(tidycensus)
options(tigris_use_cache = TRUE)
```
#Coding

```{r}
# Load state and county data
#states_sf <- states(class = "sf")**
#counties_sf <- counties(class = "sf")**

states <- tigris::states(cb = TRUE, class = "sf")  
counties <- tigris::counties(cb = TRUE, class = "sf")
# cb = TRUE for a low-resolution version for faster processing
# Visualize the map with state and county boundaries
#map <- mapview::mapview(states) + mapview::mapview(counties)**
#print(map)**

all_sf <- bind_rows(
  mutate(states, type = "state"),
  mutate(counties, type = "county")
)
mapview::mapview(all_sf)
```
```{r}
# Filter out US territories from dataset
# List of US states
us_states <- c("alabama", "arizona", "arkansas", "california", 
               "colorado", "connecticut", "delaware", "florida", "georgia", 
               "idaho", "illinois", "indiana", "iowa", "kansas", 
               "kentucky", "louisiana", "maine", "maryland", "massachusetts", 
               "michigan", "minnesota", "mississippi", "missouri", "montana", 
               "nebraska", "nevada", "new hampshire", "new jersey", "new mexico", 
               "new york", "north carolina", "north dakota", "ohio", 
               "oklahoma", "oregon", "pennsylvania", "rhode island", "south carolina", 
               "south dakota", "tennessee", "texas", "utah", "vermont", 
               "virginia", "washington", "west virginia", "wisconsin", "wyoming")
all_sf <- all_sf %>%
  filter(tolower(STATE_NAME) %in% us_states)
unique(all_sf$STATE_NAME)
```

```{r}
#Load birth rate data from NCHS
birthrate <- read_excel("C:/Users/melon/OneDrive/Desktop/Masters/Hertie/Geospatial/NCHS2016-Teen_Birth_Rates.xlsx")

#Load Sex Education data by State from Guttmacher Data Center
sexedu <-read_excel("C:/Users/melon/OneDrive/Desktop/Masters/Hertie/Geospatial/GuttmacherDataCenter-SexEdbyState_treated.xlsx")
```

```{r}
# Merge birthrate data with all_sf
all_sf <- all_sf %>%
  left_join(birthrate, by = c("NAME" = "County", "STATE_NAME" = "State"))

# Merge sex education data with all_sf
all_sf <- all_sf %>%
  left_join(sexedu, by = c("STATE_NAME" = "U.S. State"))
``` 


```{r}
#Determine best # of groups to put separate birthrate data into
library(cluster)  # For clustering algorithms
print(head(birthrate))
# Assuming 'birthrate' is your dataframe and 'Birth_Rate' is the column
data <- birthrate$`Birth Rate` %>% na.omit()  # Remove NA values for clustering
wss <- map_dbl(1:10, function(k) {
  kmeans(data, centers = k, nstart = 25)$tot.withinss
})

# Plotting the within-group sum of squares by number of clusters
qplot(1:10, wss, geom = "line") +
  labs(x = "Number of Clusters", y = "Total Within Sum of Squares", title = "Elbow Method for Optimal k")

```
#Clean dataset of NAs
```{r}
# Need to remove NAs so I can run Spatial Autocorrelations/Moran's Test
all_sf_clean <- all_sf %>%
  filter(!is.na(`Birth Rate`))
```

##Create State Geometries
```{r}
# Assuming all_sf_clean is already an sf object
states_geom <- all_sf_clean %>%
  group_by(STATE_NAME) %>%
  summarise(geometry = st_union(geometry)) %>%
  ungroup()

# Check the result
print(states_geom)
```


# Map birth rate by county
```{r}
custom_palette <- colorRampPalette(c("blue", "pink", "red"))(100)  

tmap_mode("plot")

tm <- tm_shape(all_sf) +
  tm_polygons("Birth Rate", id = "NAME",
              palette = custom_palette, title = "Teen Birth Rate by County",
              style = "quantile", n = 3,
              border.col = "black", border.alpha = 0.5) +
  tm_shape(states_geom) +  # Add the shape for the states
  tm_borders(lwd = 1.5, col = "black") +  # Draw state borders
  tm_layout(
    frame = FALSE,
    main.title = "Average Teen Birth Rate by County",
    font.size = 10,  # Adjust base font size
    outer.margins = c(0, 0.02, 0.02, 0.02),  # Reduce outer margins
    legend.position = c("right", "bottom"),
    legend.bg.color = "white",  # Adding background color to legend for better readability
    legend.bg.alpha = 0.7,  # Semi-transparent background for legend
    legend.text.size = 0.8,  # Adjust legend text size
    legend.title.size = 0.9,  # Adjust legend title size
    tm_title("Teen Birth Rate by County")  # Corrected to be inside tm_layout for tmap v3+
  ) +
  tm_scale_bar(
    position = c("left", "bottom"),
    breaks = c(0, 100, 200, 300, 400, 500)
  )

print(tm)
```

#Average Teen Birth Rate by State
##Modify State dataset
```{r}
# Aggregate birth rate data to the state level by calculating the mean birth rate per state
states <- tigris::states(cb = TRUE, class = "sf") 
state_birthrate <- all_sf %>%
  group_by(STATE_NAME) %>%
  summarise(Avg_Birth_Rate = mean(`Birth Rate`, na.rm = TRUE), .groups = 'drop')

state_birthrate <- as.data.frame(state_birthrate)

# Perform the join


states <- left_join(states, sexedu, by = c("NAME" = "U.S. State"))
states <- left_join(states, state_birthrate, by = c("NAME" = "STATE_NAME")) 
states <- states %>%
 filter(!is.na(Avg_Birth_Rate))
```

##Map
```{r}
tm_states_birthrate <- tm_shape(states) +
  tm_polygons("Avg_Birth_Rate", id = "NAME",
              palette = colorRampPalette(c("blue", "pink", "red"))(100), 
              title = "Average Teen Birth Rate by State",
              style = "quantile", n = 3,
              border.col = "black", border.alpha = 0.5) +
  tm_layout(
    main.title = "Average Birth Rate by State",
    main.title.position = "center",
    legend.text.size = 0.6,
    legend.title.size = 0.7) +
  tm_scale_bar(
    position = c("left", "bottom"),
    breaks = c(0, 100, 200, 300, 400, 500)
  )

# Print the map
print(tm_states_birthrate)
```

##Average Teen Birth Rate by State and Sex Education Level

```{r}
#Map
tm_map <- tm_shape(states) +
  tm_polygons("SexEdu",
              title = "Sex Education Level",
              palette = colorRampPalette(c("lightblue", "blue", "darkblue","red"))(4),  # Ensure the palette function is called correctly
              id = "NAME") +  # Close parentheses correctly here
  tm_layout(
    main.title = "Sex Education Policy by State",
    main.title.position = "center",
    legend.text.size = 0.6,
    legend.title.size = 0.7)

# Print the map
print(tm_map)
```
```{r}
states$SexEdu <- factor(states$SexEdu, levels = c("No Sex Ed", "No Contraception/Abstinence Pregnancy Education","Abstinence", "Abstinence/Contraception"))
states$Rate_Group <- cut(states$Avg_Birth_Rate, breaks = 3, labels = c("Low", "Medium", "High"))
```

```{r}
ggplot(data = states) +
  # Layer for color fill based on birth rate (without patterns)
  geom_sf(aes(fill = Rate_Group), color = "white", size = 0.2) +
  # Layer for patterns based on sex education (transparent fill to keep birth rate colors)
  geom_sf_pattern(aes(pattern = SexEdu),
                  fill = NA,  # No fill color, just the pattern
                  pattern_color = "black",
                  pattern_density = 0.1,
                  pattern_spacing = 0.02,
                  color = NA) +  # No border color for patterns
  scale_fill_manual(values = c("Low" = "blue", "Medium" = "pink", "High" = "red"),
                    name = "Average Birth Rate") +
  scale_pattern_manual(values = c("No Sex Ed" = "stripe",
                                  "No Contraception/Abstinence Pregnancy Education" = "crosshatch",
                                  "Abstinence" = "circle",
                                  "Abstinence/Contraception" = "none"),
                       name = "Sex Education Level") +
  labs(title = "Teenage Birth Rates and Sex Ed. Policy by State") +
  theme_minimal() +
  theme(
    legend.position = "right",
    plot.title = element_text(hjust = 0.5),
    legend.text = element_text(size = 8),  # Smaller legend text
    legend.title = element_text(size = 10), # Smaller legend title
    legend.key.size = unit(0.5, "cm"),
    panel.grid.major = element_blank(),  # Remove major gridlines
    panel.grid.minor = element_blank(),  # Remove minor gridlines
    panel.border = element_rect(colour = "black", fill=NA, size=1),
    axis.text.x = element_blank(),  # Remove x axis labels
    axis.text.y = element_blank(),  # Remove y axis labels
    axis.ticks = element_blank()  # Remove axis ticks
  )

```


#Plotting Neighbors

```{r}
#See neighbors
nb<-poly2nb(all_sf_clean,queen=TRUE)
nb
```

#Computing Spatial Autocorrelation:Global Moran's I

## Neighborhood based on contiguity (row standardized weights)	
```{r}
# Create weights for neighbors w/ style Binary 
nb_clean <- poly2nb(all_sf_clean)

nbw <- nb2listw(nb_clean, style = "W", zero.policy = T)

#hypothesis set to "greater", meaning I expect a positive autocorrelation
gmoran <- moran.test(all_sf_clean$`Birth Rate`, nbw,
                     alternative = "greater")
gmoran
```

```{r}
moran.plot(all_sf_clean$`Birth Rate`, nbw, labels=F)
```


##Neighborhood based on contiguity (inverse distance weights)
```{r}
centroid_coords <- st_centroid(all_sf_clean)
```

# invert distances, such that closer areas have higher values

```{r}
# compute distance for all spatial neighbour links
dists <- nbdists(nb, centroid_coords)

# Invert distances, handle zero by replacing with NA or a large number
inverted_dists <- lapply(dists, function(x) ifelse(x == 0, NA, 1/x))

# Clean NA and infinite values in inverted distances
inverted_dists <- lapply(inverted_dists, function(x) {
  x[is.na(x) | is.infinite(x)] <- 0  # Replace NA or infinite with 0 or some small number
  return(x)
})


# glist: list of general weights corresponding to neighbors; 
# Use style=B to maintain the weights as set with glist
nbb <- nb2listw(nb, glist = inverted_dists, style = "B", zero.policy = TRUE)
gmoran_inverted <- moran.test(all_sf_clean$`Birth Rate`, nbb,
                     alternative = "greater")
gmoran_inverted
```

```{r}
moran.plot(all_sf_clean$`Birth Rate`, nbb, labels=F)

```


##Neighbors within Distance of 75km
```{r}
#Check to see if coordinates are planar or geographical: Results are geographical
crs<-st_crs(all_sf_clean)
crs
```


```{r}
# Neighbors based on distance
# d1: lower distance bound 
# d2: upper distance bound in the metric of the points if planar coordinates, in km if in geographical coordinates
nb75 <- dnearneigh(x = centroid_coords, d1 = 0, d2 = 75)
        
nbw75<- nb2listw(nb75, style = "W", zero.policy = T)

#hypothesis set to "greater", meaning I expect a positive autocorrelation
gmoran75 <- moran.test(all_sf_clean$`Birth Rate`, nbw75,
                     alternative = "greater")
gmoran75
```



##5 nearest neighbors (row standardised weights)

```{r}
nb5 <- knn2nb(knearneigh(centroid_coords, k = 5)) 
plot(st_geometry(all_sf_clean), border = "lightgray")
plot.nb(nb5, st_geometry(all_sf_clean), add = TRUE, arrows=T)
```

```{r}
nbw5<- nb2listw(nb5, style = "W", zero.policy = T)

#hypothesis set to "greater", meaning I expect a positive autocorrelation
gmoran1 <- moran.test(all_sf_clean$`Birth Rate`, nbw5,
                     alternative = "greater")
gmoran1

```

```{r}
moran.plot(all_sf_clean$`Birth Rate`, nbw5, labels=F)
```

#Compute local Moran's with highest Moran's value (5 nearest neighbors)
```{r}
lmoran <- localmoran(all_sf_clean$`Birth Rate`, nbw5, alternative = "two.sided")
head(lmoran)
```

#Plot Morans I Clusters
```{r}
tmap_mode("plot")
```


```{r}
## tmap mode set to interactive viewing
all_sf_clean$lmI <- lmoran[, "Ii"] # local Moran's I
# p-values corresponding to alternative greater
all_sf_clean$lmp <- lmoran[, "Pr(z != E(Ii))"]
all_sf_clean$lmI_sign <- all_sf_clean$lmI
# Handle NA values explicitly in your subsetting
all_sf_clean$lmI_sign[all_sf_clean$lmp >= 0.05 & !is.na(all_sf_clean$lmp)] <- NA

# Assign 'non-significant' to 'quadr' where p-values are not significant or are NA
all_sf_clean$quadr[all_sf_clean$lmp >= 0.05 & !is.na(all_sf_clean$lmp)] <- "non-significant"


# get quadrant information
all_sf_clean$quadr <- attributes(lmoran)$quadr$mean
levels(all_sf_clean$quadr) <- c(levels(all_sf_clean$quadr), "non-significant")
all_sf_clean[(all_sf_clean$lmp >= 0.05) & !is.na(all_sf_clean$lmp), "quadr"] <- "non-significant"

#plot
tm_shape(all_sf_clean) +
  tm_polygons("quadr", 
              palette = c("blue", "lightpink", "skyblue2", "red", "white"), 
              lwd=0.1, alpha = 0.7) +
tm_shape(states_geom) +
  tm_borders(lwd = 1.5, col = "black") + # Adding state borders
  tm_layout(main.title = "Local Moran's I Clusters by County",
          main.title.size = 0.8,
          legend.title.size = 0.7,
          legend.text.size = 0.6)
```
#Table of Counties in each group
```{r}
table(all_sf_clean$quadr)

```


#Compute local Moran's with highest Moran's value (Inverted Distance)
```{r}
lmoran <- localmoran(all_sf_clean$`Birth Rate`, nbb, alternative = "two.sided")
head(lmoran)
```

#Plot Morans I Clusters
```{r}
tmap_mode("plot")
```


```{r}
## tmap mode set to interactive viewing
all_sf_clean$lmI <- lmoran[, "Ii"] # local Moran's I
# p-values corresponding to alternative greater
all_sf_clean$lmp <- lmoran[, "Pr(z != E(Ii))"]
all_sf_clean$lmI_sign <- all_sf_clean$lmI
# Handle NA values explicitly in your subsetting
all_sf_clean$lmI_sign[all_sf_clean$lmp >= 0.05 & !is.na(all_sf_clean$lmp)] <- NA

# Assign 'non-significant' to 'quadr' where p-values are not significant or are NA
all_sf_clean$quadr[all_sf_clean$lmp >= 0.05 & !is.na(all_sf_clean$lmp)] <- "non-significant"


# get quadrant information
all_sf_clean$quadr <- attributes(lmoran)$quadr$mean
levels(all_sf_clean$quadr) <- c(levels(all_sf_clean$quadr), "non-significant")
all_sf_clean[(all_sf_clean$lmp >= 0.05) & !is.na(all_sf_clean$lmp), "quadr"] <- "non-significant"

#plot
tm_shape(all_sf_clean) +
  tm_polygons("quadr", 
              palette = c("blue", "lightpink", "skyblue2", "red", "white"), 
              lwd=0.1, alpha = 0.7) +
tm_shape(states_geom) +
  tm_borders(lwd = 1.5, col = "black") + # Adding state borders
  tm_layout(main.title = "Local Moran's I Clusters by County",
          main.title.size = 0.8,
          legend.title.size = 0.7,
          legend.text.size = 0.6)
```
Table of Counties in each group
```{r}
table(all_sf_clean$quadr)
```


##Neighborhood based on contiguity (row standardized weights): 
```{r}
lmoran <- localmoran(all_sf_clean$`Birth Rate`, nbw, alternative = "two.sided")
head(lmoran)
```

###Plot Morans I Clusters

```{r}
## tmap mode set to interactive viewing
all_sf_clean$lmI <- lmoran[, "Ii"] # local Moran's I
# p-values corresponding to alternative greater
all_sf_clean$lmp <- lmoran[, "Pr(z != E(Ii))"]
all_sf_clean$lmI_sign <- all_sf_clean$lmI
# Handle NA values explicitly in your subsetting
all_sf_clean$lmI_sign[all_sf_clean$lmp >= 0.05 & !is.na(all_sf_clean$lmp)] <- NA

# Assign 'non-significant' to 'quadr' where p-values are not significant or are NA
all_sf_clean$quadr[all_sf_clean$lmp >= 0.05 & !is.na(all_sf_clean$lmp)] <- "non-significant"


# get quadrant information
all_sf_clean$quadr <- attributes(lmoran)$quadr$mean
levels(all_sf_clean$quadr) <- c(levels(all_sf_clean$quadr), "non-significant")
all_sf_clean[(all_sf_clean$lmp >= 0.05) & !is.na(all_sf_clean$lmp), "quadr"] <- "non-significant"

#plot
tm_shape(all_sf_clean) +
  tm_polygons("quadr", 
              palette = c("blue", "lightpink", "skyblue2", "red", "white"), 
              lwd=0.1, alpha = 0.7) +
tm_shape(states_geom) +
  tm_borders(lwd = 1.5, col = "black") + # Adding state borders
  tm_layout(main.title = "Local Moran's I Clusters by County",
          main.title.size = 0.8,
          legend.title.size = 0.7,
          legend.text.size = 0.6)
```

```{r}
table(all_sf_clean$quadr)
```
 